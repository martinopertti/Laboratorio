<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Medición y diseño de investigación</title>
    <meta charset="utf-8" />
    <meta name="author" content="FCS-UdelaR - Martín Opertti y Fabricio Carneiro" />
    <meta name="date" content="2023-06-09" />
    <script src="libs/header-attrs-2.20/header-attrs.js"></script>
    <script src="libs/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"<i class=\"fa fa-clipboard\"><\/i>","success":"<i class=\"fa fa-check\" style=\"color: #90BE6D\"><\/i>","error":"<i class=\"fa fa-times-circle\" style=\"color: #F94144\"><\/i>"})</script>
    <link href="libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
    <link href="libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <link href="libs/animate.css-3.7.2/animate.xaringan.css" rel="stylesheet" />
    <link href="libs/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <script src="libs/fabric-4.3.1/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble-0.0.1/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble-0.0.1/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <link href="libs/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="estilo.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Medición y diseño de investigación
]
.subtitle[
## Clase 2: Manipulación de datos
]
.author[
### FCS-UdelaR - Martín Opertti y Fabricio Carneiro
]
.date[
### June 09, 2023
]

---

class: inverse, center, middle



# Directorios de trabajo 

---

## Directorios de trabajo 
- Para abrir en R un archivo guardado en tu computadora, debes especificar en qué carpeta está guardado, para esto hay varias opciones. Hay muchas opciones, una de ellas es fijar un directorio por defecto (es decir, especificarle a R la carpeta en la que vamos a trabajar):

.codefont[

```r
# Puedo fijar el directorio de trabajo con la función setwd()
# Fijar la carpeta donde vamos a importar y exportar los archivos:
setwd("micompu/micarpeta") 
getwd() # Con está función puedo consultar el directorio
```
]

.codefont[

```r
# Ahora, si quiero leer un archivo que esté en "micompu/micarpeta" simplemente 
# escribo su nombre dentro de la función, en el lugar del "path".

# Supongamos que tengo dentro de la carpeta "micarpeta" un excel con datos
# de desempleo en Uruguay:

library(readxl)
desempleo_uru &lt;- read_excel("data/desempleo.xlsx")
```

```
## Error: `path` does not exist: 'data/desempleo.xlsx'
```

```r
head(desempleo_uru, 4)
```

```
## Error in head(desempleo_uru, 4): object 'desempleo_uru' not found
```
]

---

## Crear una carpeta

En la computadora en la que estés trabajando debes crear una carpeta (dentro de la carpeta que prefieras o en el escritorio), con las siguientes carpetas dentro:

- **Data** Descargar de EVA la carpeta data dentro de la sección laboratorio y pegar el contenido aquí.
- **Scripts** Descargar los distintos scripts (archivos de código) del EVA y guardarlos en esta carpeta (código de la clase, ejercicios, etc.)
- **graficos** Crear una carpeta gráficos que por el momento esté vacía, vamos a ir incluyendo guardando archivos ahí 
- **resultados** Crear una carpeta resultados que por el momento esté vacía, vamos a ir incluyendo guardando archivos ahí


---

## Carpeta del curso

Deberían ver en su carpeta algo así:

.center[
&lt;img src="ima/carpeta_curso.png" width="1000px" /&gt;
]

---

## Directorio de R

Al comienzo de cada script **deben** especificar el directorio donde está su carpeta del curso, de lo contrario los códigos les van a devolver errores. 

En este caso, por ejemplo, creé la carpeta "laboratorio" dentro de una carpeta llamada "Medicion y diseño" dentro de "cursos". Para acceder al directorio completo vayan a donde esta su carpeta hagan click derecho en la carpeta, seleccionen "propiedades" y luego ahí bajo dirección pueden copiar el directorio.


```r
setwd("C:/Usuario/Martin/Dropbox/cursos/Medicion y diseño/laboratorio") 
```

De esta forma, por ejemplo, si queremos leer una base de datos llamada "datauru.xlsx" que está guardada en la carpeta data dentro de la carpeta laboratorio, simplemente tenemos que especificar la siguiente dirección (porque R ya lo va a buscar dentro de la carpeta laboratorio)


```r
datauru &lt;- read_excel("data/datauru.xlsx") 
```


---
class: inverse, center, middle

# Importar y exportar datos

---

## Importar datos
- Hasta ahora trabajamos principalmente con datos ingresados manualmente con las funciones `c()` y `data.frame()`

- Normalmente cuando trabajamos con datos solemos utilizar datos ya creados guardados en los formatos de otros programas (ej. Excel, Stata, SPSS) 

- Existen varios paquetes que permiten importar y exportar datos desde distintos formatos. Algunos de los más utilizados son [readr](https://readr.tidyverse.org/), [haven](https://haven.tidyverse.org/), [readxl](https://readxl.tidyverse.org/) y [utils](https://www.rdocumentation.org/packages/utils/versions/3.6.2)

- El primer paso es siempre identificar la extensión del archivo que queremos importar. Por ejemplo, las planillas excel (dependiendo de la versión) suelen tener extension .xlsx

- Pueden consultar la extensión de un archivo con botón derecho + propiedades

---

## Importar datos 
Distintas funciones nos sirven para importar datos a R desde distintos formatos. Veamos algunos ejemplos:

.codefont[

```r
# Con la función read_csv() del paquete readr importamos archivos .csv
library(tidyverse)
gapminder_csv &lt;- read_csv("data/gapminder.csv")

# Con la función read_excel() del paquete readxl importamos archivos excel
library(readxl)
gapminder_excel &lt;- read_excel("data/gapminder.xlsx")
```
]

.codefont[

```r
# Vemos que los dataframes son iguales, tienen la mismas filas y columnas
dim(gapminder_csv)
```

```
## [1] 1704    6
```

```r
dim(gapminder_excel)
```

```
## [1] 1704    6
```
]
---

## Importar datos
Algunos paquetes incluyen datos, por ejemplo, gapminder. En la documentación del paquete se encuentra el nombre de los datos. Con una simple asignación los podemos cargar 

```r
#install.packages("gampminder")
library(gapminder)

data_gapminder &lt;- gapminder
head(data_gapminder)
```

```
## # A tibble: 6 × 6
##   country     continent  year lifeExp      pop gdpPercap
##   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
## 1 Afghanistan Asia       1952    28.8  8425333      779.
## 2 Afghanistan Asia       1957    30.3  9240934      821.
## 3 Afghanistan Asia       1962    32.0 10267083      853.
## 4 Afghanistan Asia       1967    34.0 11537966      836.
## 5 Afghanistan Asia       1972    36.1 13079460      740.
## 6 Afghanistan Asia       1977    38.4 14880372      786.
```

---

## Importar datos
También es posible importar datos guardados en los formatos de otros softwares estadísticos como SPSS o Stata. Para esto usaremos el paquete haven.

.codefont[

```r
library(haven)

# SPSS
gapminder_spss &lt;- read_spss("data/gapminder.sav") 

# STATA
gapminder_stata &lt;- read_stata("data/gapminder.dta") 
```
]

O podríamos llamar a la función y paquete dado que generalmente solo utilizamos una función de los paquetes que cargan datos (depende del caso obviamente)

.codefont[

```r
# SPSS
gapminder_spss &lt;- haven::read_spss("data/gapminder.sav") 

# STATA
gapminder_stata &lt;- haven::read_stata("data/gapminder.dta") 
```
]

---

## Importar datos 
R también cuenta con sus propios formatos de almacenamiento de datos (`.rds` y `.Rdata` o `.rda`). Este enfoque es poco práctico si queremos usar los datos almacenados en otro programa, pero muy útil si solamente usaremos R dado que mantiene la información tal cual estaba en R (por ej. tipos de variables o atributos):

.codefont[

```r
# Para esto no necesitamos cargar paquetes. 
# Guardar un objeto como .rds:
saveRDS(object = data_gapminder,
        file = "resultados/data_gapminder.rds") 

 # Leemos un archivo .rds
miobjeto_rds &lt;- readRDS(file = "resultados/data_gapminder.rds")

# Con .rda se pueden guardar varios objetos al mismo tiempo!
# Exportamos un archivo .Rdata
save(data_gapminder, miobjeto_rds,
     file = "resultados/dos_dataframes.Rdata") 

 # Importamos un archivo .Rdata
load("resultados/dos_dataframes.Rdata")
```
]

---

## Exportar datos 
- También podemos guardar archivos desde R en otros formatos. 
- Con [readr](https://readr.tidyverse.org/) podemos exportar archivos en formato .csv 
- Con [writexl](https://cran.r-project.org/web/packages/writexl/writexl.pdf) podemos exportar directamente un excel.
- Con [haven](https://www.rdocumentation.org/packages/haven/versions/2.3.1) podemos exportar achivos en formato .dta (Stata) y .sav (SPSS)

.codefont[

```r
# Guardar .csv
library(gapminder)
data_gapminder &lt;- gapminder
write_excel_csv(data_gapminder, "resultados/gapminder.csv")

# Guardar excel
library(writexl)
write_xlsx(data_gapminder, "resultados/gapminder.xlsx")

# Guardar .dta (Stata)
library(haven)
write_dta(data_gapminder, "resultados/gapminder.dta")

# Guardar .sav (SPSS)
write_sav(data_gapminder, "resultados/gapminder.sav")

# Guardar .sas (SAS)
write_sas(data_gapminder, "resultados/gapminder.sas")
```
]

---

## Etiquetas cuando importamos datos

- Cuando importamos datos que tienen etiquetas (por ejemplo de formatos como Stata o SPSS) debemos tener cuidado con cómo manejar estas etiquetas

- Por ejemplo, supongamos que queremos leer los datos de una encuesta con dos variables, guardada en formato Stata (`.dta`), con el paquete `haven`:

.codefont[

```r
data &lt;- haven::read_stata("data/ej_encuesta.dta")
head(data, 5)
```

```
## # A tibble: 5 × 2
##   P1              P14                 
##   &lt;dbl+lbl&gt;       &lt;dbl+lbl&gt;           
## 1  4 [Colonia]    1 [Muy mala]        
## 2 18 [Tacuarembó] 2 [Mala]            
## 3 15 [Salto]      5 [Muy buena]       
## 4  1 [Artigas]    3 [Ni buena ni mala]
## 5 10 [Montevideo] 1 [Muy mala]
```
]

- Por defecto se leen como variables de tipo `double` (numérica) con etiquetas como atributos

---

## Etiquetas cuando importamos datos

Si queremos quedarnos directamente coon las etiquetas, podemos utilizar la funcion `as_factor`:


```r
data &lt;- haven::read_stata("data/ej_encuesta.dta") %&gt;% 
  as_factor()
head(data, 5)
```

```
## # A tibble: 5 × 2
##   P1         P14             
##   &lt;fct&gt;      &lt;fct&gt;           
## 1 Colonia    Muy mala        
## 2 Tacuarembó Mala            
## 3 Salto      Muy buena       
## 4 Artigas    Ni buena ni mala
## 5 Montevideo Muy mala
```

---

## Importar y exportar datos: factores

- Otro tipo de variables en R son los factores (factors), utilizados para representar data categórica. Estos suelen confundirse con las variables de caracteres pero tienen algunas diferencias. 

- Normalmente los factores son utilizados para las variables de caracteres con un número de valores posibles fijo y cierto orden (opcional)

- A R le gusta transformar las variables de caracteres en factores al importarlas (si usamos R Base particularmente).

- El paquete [forcats](https://forcats.tidyverse.org/) (dentro del Tidyverse) ayuda a manejar variables de caracteres y factores:
    - `fct_relevel()` cambia manualmente el orden de los niveles
    - `fct_reoder()` cambia el orden de los niveles de acuerdo a otra variable
    - `fct_infreq()` reordena un factor por la frecuencia de sus valores 
    - `fct_lump()` collapsa los valores menos frecuentes en otra categoría "other". Es muy útil para preparar datos para tablas y gráficos

---

## Importar y exportar datos: factores 

.codefontchico[

```r
# Podemos chequear y coercionar factores
data_gapminder &lt;- gapminder
is.factor(data_gapminder$continent) # Chequeo si es factor
```

```
## [1] TRUE
```

```r
levels(data_gapminder$continent) # Chequeo los niveles
```

```
## [1] "Africa"   "Americas" "Asia"     "Europe"   "Oceania"
```

```r
# Transformo a caracter
data_gapminder$continent &lt;- as.character(data_gapminder$continent) 
class(data_gapminder$continent)
```

```
## [1] "character"
```

```r
# De vuelta a factor
data_gapminder$continent &lt;- as.factor(data_gapminder$continent)
class(data_gapminder$continent)
```

```
## [1] "factor"
```
]

---
class: inverse, center, middle

# Explorar Dataframes 

---

## Resumen de un dataframe

.codefont[

]

.codefont[

```r
dim(data_gapminder) # Número de filas y columnas
```

```
## [1] 1704    6
```

```r
names(data_gapminder) # Nombre de variables
```

```
## [1] "country"   "continent" "year"      "lifeExp"   "pop"       "gdpPercap"
```

```r
head(data_gapminder, 3) # Imprime primeras filas (3 en este caso)
```

```
## # A tibble: 3 × 6
##   country     continent  year lifeExp      pop gdpPercap
##   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
## 1 Afghanistan Asia       1952    28.8  8425333      779.
## 2 Afghanistan Asia       1957    30.3  9240934      821.
## 3 Afghanistan Asia       1962    32.0 10267083      853.
```
]

---

## Resumen de un dataframe 

Una de las funciones más utiles para resumir un dataframe es `glimpse()` del paquete dplyr o tidyverse. Es particularmente util debido a que permite un vistazo al nombre, tipo y primeros valores de .bold[todos] las variables de un dataframe.


```r
# Resumen más completo:
glimpse(gapminder) 
```

```
## Rows: 1,704
## Columns: 6
## $ country   &lt;fct&gt; "Afghanistan", "Afghanistan", "Afghanistan", "Afghanistan", …
## $ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …
## $ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …
## $ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…
## $ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…
## $ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …
```

---
## Tablas simples

En R Base la función para obtener frecuencias es `table()` junto con `prop.table()` y `addmargins()`

.codefontchico[

```r
# Para obtener una tabla de frecuencias de una variable usamos la función
# table() de R Base
tabla_1 &lt;- table(data_gapminder$continent) # Frecuencia simple
tabla_1 
```

```
## 
##   Africa Americas     Asia   Europe  Oceania 
##      624      300      396      360       24
```

```r
prop.table(tabla_1) # Proporciones
```

```
## 
##     Africa   Americas       Asia     Europe    Oceania 
## 0.36619718 0.17605634 0.23239437 0.21126761 0.01408451
```

```r
addmargins(tabla_1) # Totales
```

```
## 
##   Africa Americas     Asia   Europe  Oceania      Sum 
##      624      300      396      360       24     1704
```

```r
addmargins(prop.table(tabla_1)) # Proporciones y totales
```

```
## 
##     Africa   Americas       Asia     Europe    Oceania        Sum 
## 0.36619718 0.17605634 0.23239437 0.21126761 0.01408451 1.00000000
```
]

---
class: inverse, center, middle

# Estadística descriptiva

---

## Medidas de tendencia central 

.codefont[

```r
mean(data_gapminder$lifeExp) # Media
```

```
## [1] 59.47444
```

```r
median(data_gapminder$lifeExp) # Mediana
```

```
## [1] 60.7125
```

```r
sd(data_gapminder$lifeExp) # Desvío estandar
```

```
## [1] 12.91711
```
]

---

## Rangos 


```r
range(data_gapminder$lifeExp) # Rango
```

```
## [1] 23.599 82.603
```

```r
max(data_gapminder$lifeExp)
```

```
## [1] 82.603
```

```r
min(data_gapminder$lifeExp)
```

```
## [1] 23.599
```

---

## Histogramas 
También podemos graficar los datos rápidamente. Por ejemplo, un histograma:

.center[
.codefont[

```r
hist(data_gapminder$lifeExp,
     main = "Distribución de expectativa de vida (Gapminder)")
```

&lt;img src="clase_2_files/figure-html/ej22-1.png" width="400px" /&gt;
]
]
---

## Gráfico de dispersión (scatterplot) 

.center[

```r
plot(data_gapminder$lifeExp, data_gapminder$gdpPercap,
     main = "Relación entre expectativa de vida y PBI per cápita")
```

&lt;img src="clase_2_files/figure-html/ej22_b-1.png" width="400px" /&gt;
]


---
class: inverse, center, middle

# Transformar datos

---
## Transformar datos con dplyr

El paquete dplyr contiene funciones muy útiles para la transformación de dataframes (tibbles). Todas las funciones tienen en común que su primer argumento es un dataframe y que devuelven un dataframe. Algunas de las funciones que vamos a ver:

- `filter()`: filtrar observaciones en base a valores
- `select()`: filtrar variables 
- `mutate()`: crear o recodificar variables
- `group_by()`: define grupos de valores utilizar las otras funciones
- `summarise()`: colapsa valores según alguna fórmula (sumar, número de casos, media, etc.)

---
## Filtrar
Una de las tareas más comunes en el análisis de datos es filtrar observaciones en base a condiciones. Existen muchas maneras de filtrar datos en R, la función `filter()` de dplyr es una de las más sencillas de utilizar. El primer argumento es el dataframe y el segundo la condición por la que queremos filtrar.

.codefont[

```r
# Tenemos datos de muchos años:
table(gapminder$year)
```

```
## 
## 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 
##  142  142  142  142  142  142  142  142  142  142  142  142
```

```r
# Filtremos para con los datos a partir de 2007
gapminder_07 &lt;- filter(gapminder, year == 2007)
table(gapminder_07$year)
```

```
## 
## 2007 
##  142
```
]

---
## Filtrar

Utilizando operadores lógicos podemos filtrar de formas más complejas:


```r
# Todas los años menos 2007
gapminder_pre07 &lt;- filter(gapminder, year != 2007)
table(gapminder_pre07$year)
```

```
## 
## 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 
##  142  142  142  142  142  142  142  142  142  142  142
```

```r
# Solo los siguientes años: 1952, 1992 y 2007
anios_especificos &lt;- c(1952, 1992, 2007)
gapminder_esp &lt;- filter(gapminder, year %in% anios_especificos)

table(gapminder_esp$year)
```

```
## 
## 1952 1992 2007 
##  142  142  142
```

---
## Seleccionar variables
Con `select()` podemos seleccionar las variables (columnas) que queremos mantener en un dataframe. Podemos nombrarlas, seleccionar cuáles queremos eliminar y referirnos por su orden:


```r
# Selccionar un conjunto de variables (país, año, población)
select(gapminder, country, year, pop)

# Selccionar todas las variables menos las especificadas
select(gapminder, -continent)

# Seleccionar un rango de variables según orden
select(gapminder, country:lifeExp)
select(gapminder, 1:3) # Orden numérico
```

---

## Pipeline %&gt;% 

Cuando queremos realizar más de una operación a un dataframe podemos utilizar el pipeline. Como vimos, la mayoría de las funciones de dplyr que se aplican a un dataframe tienen como primer argumento el dataframe al que le queremos aplicar la función. 

Con el pipeline especificamos el dataframe solamente una vez al principio, y luego todas las funciones que vamos utilizando no necesitan especificación. De esta forma nos enfocamos en la transformación y no en el objeto.

.codefont[

```r
gapminder_07_america &lt;- gapminder %&gt;% 
  filter(year == 2007 &amp; continent == "Americas") %&gt;% 
  select(-continent)

print(gapminder_07_america)
```

```
## # A tibble: 25 × 5
##    country             year lifeExp       pop gdpPercap
##    &lt;fct&gt;              &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;
##  1 Argentina           2007    75.3  40301927    12779.
##  2 Bolivia             2007    65.6   9119152     3822.
##  3 Brazil              2007    72.4 190010647     9066.
##  4 Canada              2007    80.7  33390141    36319.
##  5 Chile               2007    78.6  16284741    13172.
##  6 Colombia            2007    72.9  44227550     7007.
##  7 Costa Rica          2007    78.8   4133884     9645.
##  8 Cuba                2007    78.3  11416987     8948.
##  9 Dominican Republic  2007    72.2   9319622     6025.
## 10 Ecuador             2007    75.0  13755680     6873.
## # … with 15 more rows
```
]

---
## Pipeline %&gt;% 
- Una de las ventajas del Tidyverse es la facilidad con la que se puede leer e interpretar el código. Un elemento fundamental para esto es el pipeline (`%&gt;%`). Es muy útil para expresar una secuencia de muchas operaciones.

- Habíamos visto varias formas de realizar esto: sobrescribir el mismo objeto, con objetos intermedios o anidando funciones. 

- El pipeline del paquete [magrittr](https://magrittr.tidyverse.org/) hace más fácil modificar operaciones puntuales dentro de conjunto de operaciones, hace que sea más fácil leer (evitando leer de adentro hacia afuera) entre otras ventajas.

- Es recomendable evitar usar el pipeline cuando queremos trabajar más de un objeto a la vez

- `x %&gt;% f == f(x)`

- Se puede leer como un "y entonces"

---
## Otras funciones de dplyr muy útiles

- `arrange()` ordenar los datos según una o más variables

- `rename()` cambiar el nombre de las variables de un dataframe

- `pull()` y `distinct()`: con `distinct()` es posible identificar los valores distintos de una variable y con `pull()` los podemos extraer como un vector

- `slice_min()` y `slice_max()`: filtrar n observaciones de mayor o menor valor según variable. En general, la familia de funciones [slice](https://dplyr.tidyverse.org/reference/slice.html) permite filtrar observaciones en función de su posición.  

- `count()` contar observaciones por grupo

- `relocate()` cambiar el orden de columnas

---

class: inverse, center, middle

# Crear y recodificar variables 

---

## Crear variables con mutate() 
El paquete [dplyr](https://cran.r-project.org/web/packages/dplyr/dplyr.pdf) contiene la función [`mutate()`](https://www.rdocumentation.org/packages/dplyr/versions/0.5.0/topics/mutate) para crear nuevas variables. `mutate()` crea variables al final del dataframe.

.codefont[

```r
data_gapminder &lt;- gapminder

# Variable de caracteres
data_gapminder &lt;- mutate(data_gapminder, var1 = "Valor fijo") 

# Variable numérica
data_gapminder &lt;- mutate(data_gapminder, var2 = 7) 
head(data_gapminder, 3)
```

```
## # A tibble: 3 × 8
##   country     continent  year lifeExp      pop gdpPercap var1        var2
##   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;
## 1 Afghanistan Asia       1952    28.8  8425333      779. Valor fijo     7
## 2 Afghanistan Asia       1957    30.3  9240934      821. Valor fijo     7
## 3 Afghanistan Asia       1962    32.0 10267083      853. Valor fijo     7
```

```r
## Podemos escribir lo mismo de distinta manera:
data_gapminder &lt;- mutate(data_gapminder, var1 = "Valor fijo",
                                         var2 = 7)
```
]

---

## Recodificar variables con mutate() 
.codefont[
Con `mutate()` también podemos realizar operaciones sobre variables ya existentes:

```r
## Podemos recodificar usando variables y operadores aritméticos
# Calculemos el pbi total (pbi per capita * población)
d_gap &lt;- mutate(gapminder, gdp = gdpPercap * pop)
head(d_gap, 3)
```

```
## # A tibble: 3 × 7
##   country     continent  year lifeExp      pop gdpPercap         gdp
##   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1 Afghanistan Asia       1952    28.8  8425333      779. 6567086330.
## 2 Afghanistan Asia       1957    30.3  9240934      821. 7585448670.
## 3 Afghanistan Asia       1962    32.0 10267083      853. 8758855797.
```

```r
# Podemos calcular el logaritmo 
d_gap &lt;- mutate(d_gap, gdp_log = log(gdp))
head(d_gap, 2)
```

```
## # A tibble: 2 × 8
##   country     continent  year lifeExp     pop gdpPercap         gdp gdp_log
##   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;
## 1 Afghanistan Asia       1952    28.8 8425333      779. 6567086330.    22.6
## 2 Afghanistan Asia       1957    30.3 9240934      821. 7585448670.    22.7
```
]

---

## Transformaciones de tipo 

Al igual que hacíamos con los vectores, podemos tranformar el tipo de una variable 



.codefont[

```r
# Exploro tipo de variables
glimpse(d_gap)
```

```
## Rows: 1,704
## Columns: 3
## $ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …
## $ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …
## $ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…
```

```r
# Variable continente a caracteres y año a factor
d_gap &lt;- d_gap %&gt;% 
  mutate(continent = as.character(continent),
         year = as.factor(year))

glimpse(d_gap)
```

```
## Rows: 1,704
## Columns: 3
## $ continent &lt;chr&gt; "Asia", "Asia", "Asia", "Asia", "Asia", "Asia", "Asia", "Asi…
## $ year      &lt;fct&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …
## $ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…
```
]


---
class: inverse, center, middle

# Recodificaciones condicionales

---

## Recodificaciones condicionales
- Muchas veces transformar los datos implica recodificar una variable de forma condicional, esto es, asignar distintos valores en función de los valores de una o más variables.

- Para esto podemos utilizar las funciones; [ifelse()](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/ifelse) (R Base), [mutate()](https://www.rdocumentation.org/packages/dplyr/versions/0.5.0/topics/mutate), [recode()](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/recode) y [case_when()](https://dplyr.tidyverse.org/reference/case_when.html) (Tidyverse)

- Nosotros veremos recodificaciones condicionales con `case_when()` y `mutate()`

---

## Recodificación condicional con case_when y mutate

Podemos crear variables condicionales con `case_when()` del paquete  dplyr. Esencialmente, con `ifelse()` (R Base) podemos lograr lo mismo que con `case_when()` (Tidyverse). `case_when()` puede resultar más sencilla de utilizar al no haber necesidad de anidar la función cuando establecemos múltiples condiciones. 

Cuando trabajmos con dataframes `case_when()` se utiliza dentro de `mutate()`. `case_when()` testea condiciones en orden (esto es importante cuando pasamos condiciones no excluyentes). `case_when()` lista condiciones para las que asigna un valor en caso de que sean verdaderas, y permite pasar múltiples condiciones. `TRUE` refiere a las condiciones no listadas. La estructura de `case_when()` es: 



```r
data %&gt;% 
  mutate(var_nueva = case_when(var_original == "Valor 1" ~ "Valor A",
                               var_original == "Valor 2" ~ "Valor B",
                               TRUE ~ "Otros"))
```


---
## Recodificación condicional con case_when y mutate



```r
d_gap &lt;- gapminder

# Creemos una variable que indique si el país es Uruguay o no
d_gap &lt;- d_gap %&gt;% 
  mutate(uruono = case_when(
    country == "Uruguay" ~ "Si",
    TRUE ~ "No")
    )

table(d_gap$uruono)
```

```
## 
##   No   Si 
## 1692   12
```


---
## Recodificación condicional con case_when y mutate

Podemos establecer varias condiciones fácilmente:

.codefont[

```r
d_gap &lt;- gapminder

d_gap &lt;- d_gap %&gt;% 
  mutate(mercosur = case_when(country == "Uruguay" ~ 1,
                              country == "Argentina" ~ 1,
                              country == "Paraguay" ~ 1,
                              country == "Brazil" ~ 1, 
                              TRUE ~ 0))

table(d_gap$mercosur)
```

```
## 
##    0    1 
## 1656   48
```
]


---
## Recodificación condicional con case_when y mutate

También podríamos usar operadores para simplificar esto:

.codefont[

```r
d_gap &lt;- d_gap %&gt;% 
  mutate(mercosur = case_when(
  country %in% c("Argentina", "Paraguay", "Brazil", "Uruguay") ~ 1,
  TRUE ~ 0)
  ) 

d_gap &lt;- d_gap %&gt;% 
  mutate(mercosur2 = case_when(
    country == "Argentina" | country == "Paraguay" |
      country == "Brazil" | country == "Uruguay" ~ 1,
    TRUE ~ 0)
    )

identical(d_gap$mercosur, d_gap$mercosur2)
```

```
## [1] TRUE
```
]

---

## Recodificación condicional con case_when y mutate

`case_when()` sirve también para recodificar una variable con condiciones basadas en múltiples variables.

Supongamos que queremos una variable que indique los países-año con expectativa de vida mayor a 75 o pbi per cápita mayor a 20.000

.codefont[

```r
d_gap &lt;- d_gap %&gt;% 
  mutate(var1 = case_when(gdpPercap &gt; 20000 ~ 1,
                          lifeExp &gt; 75 ~ 1,
                          TRUE ~ 0))
table(d_gap$var1)
```

```
## 
##    0    1 
## 1493  211
```
]

---
class: inverse, center, middle

# Resumenes y tablas

---
## Resumir datos 

Resumir datos (tablas descriptivas) es una de las partes fundamentales del análisis de datos. Para ello utilizaremos la función `summarise()` o `summarize()`, muchas veces en conjunto con `group_by()`. 

Escencialmente `summarise()` resume un dataframe en una fila según una estadística especificada. Por ejemplo, calculando la media de una variable

.codefont[

```r
gapminder %&gt;% 
  summarise(media = mean(lifeExp, na.rm=T))
```

```
## # A tibble: 1 × 1
##   media
##   &lt;dbl&gt;
## 1  59.5
```

```r
# Por ahora no hay mucha diferencia con
mean(gapminder$lifeExp, na.rm = TRUE)
```

```
## [1] 59.47444
```
]


---
## Resumir datos 

Hasta ahora `summarise()` no nos es de gran utilidad, la utilidad de `summarise()`  es su uso conjunto con `group_by()`, para estimar diferentes estadísticas según grupos específicos. 

Cuando utilizamos `group_by()` en un pipeline cambiamos la unidad de análisis desde todo el dataframe a niveles de una variable. Retomando el ejemplo, podemos ver el promedio de expectativa de vida según año:

.codefont[

```r
gapminder %&gt;% 
  group_by(year) %&gt;% 
  summarise(media = mean(lifeExp, na.rm = T)) 
```

```
## # A tibble: 12 × 2
##     year media
##    &lt;int&gt; &lt;dbl&gt;
##  1  1952  49.1
##  2  1957  51.5
##  3  1962  53.6
##  4  1967  55.7
##  5  1972  57.6
##  6  1977  59.6
##  7  1982  61.5
##  8  1987  63.2
##  9  1992  64.2
## 10  1997  65.0
## 11  2002  65.7
## 12  2007  67.0
```
]


---
## Resumir datos 

Algunas de las operaciones más utilizadas para resumir datos:

- `mean()`: media 
- `median()`: mediana
- `sd()`: desvío estandar
- `sum()`: suma
- `n()`: número de observaciones
- `n_distinct()`: número de valores únicos
- `min()` y `max()`: mínimo y máximo
- `first()`: primer valor


---
## Resumir datos

Podemos utilizar más de una variable dentro de `group_by()`. Por ejemplo, calculemos la media de expectativa de vida por año comparando America y Europa para 1997, 2002 y 2007:

.codefont[

```r
resumen_1 &lt;- gapminder %&gt;% 
  filter(continent %in% c("Americas", "Europe")) %&gt;% 
  filter(year &gt;= 1997) %&gt;% 
  group_by(continent, year) %&gt;% 
  summarise(media = mean(lifeExp, na.rm = TRUE)) 
```

```
## `summarise()` has grouped output by 'continent'. You can override using the
## `.groups` argument.
```

```r
resumen_1
```

```
## # A tibble: 6 × 3
## # Groups:   continent [2]
##   continent  year media
##   &lt;fct&gt;     &lt;int&gt; &lt;dbl&gt;
## 1 Americas   1997  71.2
## 2 Americas   2002  72.4
## 3 Americas   2007  73.6
## 4 Europe     1997  75.5
## 5 Europe     2002  76.7
## 6 Europe     2007  77.6
```
]

---
## Resumir datos

Una de las grandes ventajas de `summarise()` es que podemos resumir muy fácilmente varias estadísticas en un solo dataframe. 

.codefont[

```r
resumen_2 &lt;- gapminder %&gt;% 
  filter(continent %in% c("Americas", "Europe")) %&gt;%
  filter(year == 2007) %&gt;%
  group_by(continent) %&gt;% 
  summarise(media = mean(gdpPercap),
            desvio = sd(gdpPercap),
            suma = sum(gdpPercap),
            max = max(gdpPercap),
            min = min(gdpPercap),
            paises = n()) 

resumen_2
```

```
## # A tibble: 2 × 7
##   continent  media desvio    suma    max   min paises
##   &lt;fct&gt;      &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;int&gt;
## 1 Americas  11003.  9713. 275076. 42952. 1202.     25
## 2 Europe    25054. 11800. 751634. 49357. 5937.     30
```
]

---
class: inverse, center, middle

# Estructura de datos

---
## Cambios de estructura

Muchas veces los resultados de funciones no están en el formato que queremos. Para pasar datos a otras estructuras tenemos las funciones `pivot_longer()` (para pasar de formato ancho a largo) y `pivot_wider()` (para pasar de formarto largo a ancho) del paquete tidyr.

.center[
&lt;img src="ima/wide_long.png" width="600px" /&gt;
]

---
## De ancho a largo con pivot_longer()

.center[
&lt;img src="ima/wide_ima.png" width="1000px" /&gt;
]

.right[[Wichkham &amp; Grolemund (2018)](https://r4ds.had.co.nz/tidy-data.html)]

---
## De ancho a largo con pivot_longer()

.codefontchico[

```r
print(resumen_2)
```

```
## # A tibble: 2 × 7
##   continent  media desvio    suma    max   min paises
##   &lt;fct&gt;      &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;int&gt;
## 1 Americas  11003.  9713. 275076. 42952. 1202.     25
## 2 Europe    25054. 11800. 751634. 49357. 5937.     30
```

```r
resumen_2_largo &lt;- resumen_2 %&gt;% 
  pivot_longer(cols = -continent, # Columnas a unir 
               names_to = "medida", # Nombre de variable "key" 
               values_to = "valor") # Nombre de variable con valores

print(resumen_2_largo)
```

```
## # A tibble: 12 × 3
##    continent medida   valor
##    &lt;fct&gt;     &lt;chr&gt;    &lt;dbl&gt;
##  1 Americas  media   11003.
##  2 Americas  desvio   9713.
##  3 Americas  suma   275076.
##  4 Americas  max     42952.
##  5 Americas  min      1202.
##  6 Americas  paises     25 
##  7 Europe    media   25054.
##  8 Europe    desvio  11800.
##  9 Europe    suma   751634.
## 10 Europe    max     49357.
## 11 Europe    min      5937.
## 12 Europe    paises     30
```
]

---
## De largo a ancho con pivot_wider()

.center[
&lt;img src="ima/long_ima.png" width="800px" /&gt;
]

.right[[Wichkham &amp; Grolemund (2018)](https://r4ds.had.co.nz/tidy-data.html)]

---
## De largo a ancho con pivot_wider()

.codefontchico[

```r
print(resumen_2_largo)
```

```
## # A tibble: 12 × 3
##    continent medida   valor
##    &lt;fct&gt;     &lt;chr&gt;    &lt;dbl&gt;
##  1 Americas  media   11003.
##  2 Americas  desvio   9713.
##  3 Americas  suma   275076.
##  4 Americas  max     42952.
##  5 Americas  min      1202.
##  6 Americas  paises     25 
##  7 Europe    media   25054.
##  8 Europe    desvio  11800.
##  9 Europe    suma   751634.
## 10 Europe    max     49357.
## 11 Europe    min      5937.
## 12 Europe    paises     30
```

```r
resumen_2_largo %&gt;% 
  pivot_wider(names_from = continent, # Variable que pasa a distintas columnas
              values_from = valor) # Variable donde se extraen los valores
```

```
## # A tibble: 6 × 3
##   medida Americas  Europe
##   &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;
## 1 media    11003.  25054.
## 2 desvio    9713.  11800.
## 3 suma    275076. 751634.
## 4 max      42952.  49357.
## 5 min       1202.   5937.
## 6 paises      25      30
```
]







    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false,
"incremental": true,
"df_print": "kable",
"smaller": true,
"widescreen": true,
"highlightLines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
